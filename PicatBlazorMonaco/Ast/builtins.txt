Basic
copy_term(Term1) = Term2: This function copies Term1 into Term2. If Term1 is an attributed variable, then Term2 will not contain any of the attributes.
copy_term_shallow(Term1) = Term2: This function copies the skeleton of Term1 into Term2. If Term1 is a variable or an atomic value, then it returns a complete copy of Term1, the same as copy_term(Term1); if Term1 is a list, then it returns a cons [H|T] where both the car H and the cdr T are free variables; otherwise, it is the same as new_struct(name(Term1),arity(Term1)).
hash_code(Term) = Code: This function returns the hash code of Term. If Term is a variable, then the returned hash code is always 0.
to_codes(Term) = Codes: This function returns a list of character codes of Term.
to_fstring(Format,Args…): This function converts the arguments in the Args… parameter into a string, according to the format string Format, and returns the string. The number of arguments in Args… cannot exceed 10. Format characters are described in Chapter 10.
to_string(Term) = String: This function returns a string representation of Term.
var(Term): This predicate is true if Term is a free variable.
nonvar(Term): This predicate is true if Term is not a free variable.
bind_vars(Term,Val): Binds all of the variables in Term to Val.
acyclic_term(Term): This predicate is true if Term is acyclic, meaning that Term does not contain itself.
and_to_list(Conj) = List: This function converts Conj in the form (a1,…,an) into a list in the form [a1,…,an].
compare_terms(Term1,Term2) = Res: This function compares Term1 and Term2 . If Term1 < Term2, then this function returns -1. If Term1 == Term2, then this function returns 0. Otherwise, Term1 > Term2, and this function returns 1.
different_terms(Term1,Term2): This constraint ensures that Term1 and Term2 are different. This constraint is suspended when the arguments are not sufficiently instantiated.
get_global_map() = Map: This function returns the global map.
get_global_map(ID) = Map: This function returns the global map with the identifier ID, which must be a ground term.
get_heap_map() = Map: This function returns the default heap map.
get_heap_map(ID) = Map: This function returns the heap map with the identifier ID, which must be ground term.
get_table_map() = Map: This function returns the default table map. The table map is stored in the table area and both keys and values are hash-consed (i.e., common sub-terms are shared).
get_table_map(ID) = Map: This function returns the table map with the identifier ID, which must be a ground term.
ground(Term): This predicate is true if Term is ground. A ground term does not contain any variables.
list_to_and(List) = Conj: This function converts List in the form [a1,…,an] into a term in the form (a1,…,an).
number_vars(Term): This predicate numbers the variables in Term by using the integers starting from 0. Different variables receive different numberings, and the occurrences of the same variable all receive the same numbering.
number_vars(Term,N0) = N1: This function numbers the variables in Term by using the integers starting from N0. N1 is the next integer that is available after Term is numbered.
parse_radix_string(String,Base) = Int: This function converts a radix String of Base into a decimal integer Int, where Base must be greater than 1 and less than 37. For example, parse_radix_string("101",2) returns 5, which is the same as parse_term("0b101").
parse_term(String,Term,V ars): This predicate uses the Picat parser to extract a term Term from String. V ars is a list of pairs, where each pair has the form Name=V ar.
parse_term(String) = Term: This function converts String to a term.
second(Compound) = Term: This function returns the second argument of the compound term Compound.
subsumes(Term1,Term2): This predicate is true if Term1 subsumes Term2.
variant(Term1,Term2): This predicate is true if Term2 is a variant of Term1.
vars(Term) = V ars: This function returns a list of variables that occur in Term.
true: This goal is always true.
fail: This goal is always false. When fail occurs in a condition, the condition is false, and the rule is never applicable. When fail occurs in a body, it causes execution to backtrack.
false: This goal is the same as fail.
-----
Attributed variables
attr_var(Term): This predicate is true if Term is an attributed variable.
dvar(Term): This predicate is true if Term is an attributed domain variable.
bool_dvar(Term): This predicate is true if Term is an attributed domain variable whose lower bound is 0 and whose upper bound is 1.
dvar_or_int(Term): This predicate is true if Term is an attributed domain variable or an integer.
get_attr(X,Key) = V al: This function returns the V al of the key-value pair Key=V al that is attached to X. It throws an error if X has no attribute named Key.
get_attr(X,Key,DefaultV al) = V al: This function returns V al of the key-value pair Key=V al that is attached to X. It returns DefaultV al if X does not have the attribute named Key.
put_attr(X,Key,V al): This predicate attaches the key-value pair Key=V al to X, where Key is a non-variable term, and V al is any term.
put_attr(X,Key): This predicate call is the same as put_attr(X,Key,not_a_value).
-----
Atoms
ascii_alpha(Term): This predicate is true if Term is an atom and the atom is made of one letter.
ascii_alpha_digit(Term): This predicate is true if Term is an atom and the atom is made of one letter or one digit.
ascii_digit(Term): This predicate is true if Term is an atom and the atom is made of one digit.
ascii_lowercase(Term): This predicate is true if Term is an atom and the atom is made of one lowercase letter.
ascii_uppercase(Term): This predicate is true if Term is an atom and the atom is made of one uppercase letter.
atom(Term): This predicate is true if Term is an atom.
atom_chars(Atm) = String: This function returns string that contains the characters of the atom Atm. It throws an error if Atm is not an atom.
atom_codes(Atm) = List: This function returns the list of codes of the characters of the atom Atm. It throws an error if Atm is not an atom.
atomic(Term): This predicate is true if Term is an atom or a number.
char(Term): This predicate is true if Term is an atom and the atom is made of one character.
chr(Code) = Char: This function returns the UTF-8 character of the code point Code.
digit(Term): This predicate is true if Term is an atom and the atom is made of one digit.
len(Atom) = Len: This function returns the number of characters in Atom. Note that this function is overloaded in such a way that the argument can also be an array, a list, or a structure.
length(Atom) = Len: This function is the same as len(Atom).
ord(Char) = Int: This function returns the code point of the UTF-8 character Char. It throws an error if Char is not a single-character atom.
-----
Numbers
between(From,To,X) (nondet): If X is bound to an integer, then this predicate determines whether X is between From and To. Otherwise, if X is unbound, then this predicate nondeterministically selects X from the integers that are between From and To. It is the same as member(X,From..To).
bigint(Term): This predicate is true if Term is a big integer.
float(Term): This predicate is true if Term is a real number.
int(Term): This predicate is true if Term is an integer.
integer(Term): The same as int(Term).
max(X,Y ) = V al: This function returns the maximum of X and Y , where X and Y are terms.
maxint_small() = Int: This function returns the maximum integer that is represented in one word. All integers that are greater than this integer are represented as big integers.
min(X,Y ) = V al: This function returns the minimum of X and Y , where X and Y are terms.
minint_small() = Int: This function returns the minimum integer that is represented in one word. All integers that are smaller than this integer are represented as big integers.
number(Term): This predicate is true if Term is a number.
number_chars(Num) = String: This function returns a list of characters of Num. This function is the same as to_fstring("%d",Num) if Num is an integer, and the same as to_fstring("%f",Num) if Num is a real number.
number_codes(Num) = List: This function returns a list of codes of the characters of Num. It is the same as number_chars(Num).to_codes().
real(Term): This predicate is the same as float(Term).
to_binary_string(Int) = String: This function returns the binary representation of the integer Int as a string.
to_float(NS) = Real: This function is the same as NS*1.0 if NS is a number, and the same as parse_term(NS) if NS is a string of digits.
to_hex_string(Int) = String: This function returns the hexadecimal representation of the integer Int as a string.
to_int(ANS) = Int: This function is the same as truncate(ANS) in the math module if ANS is a number, the same as ord(ANS)-ord(’0’) if ANS is a digit character, and the same as parse_term(ANS) if ANS is a string.
to_integer(ANS) = Int: This function is the same as to_int(ANS).
to_number(ANS) = Num: This function is the same as ANS if ANS is a number, the same as ord(ANS)-ord(’0’) if ANS is a digit character, and the same as parse_term(ANS) if ANS is a string.
to_oct_string(Int) = String: This function returns the octal representation of the integer Int as a string.
to_radix_string(Int,Base) = String: This function returns the representation of the integer Int of the numeral Base as a string, where Base must be greater than 1 and less than 37. The call to_oct_string(Int) is the same as to_radix_string(Int,8).
to_real(NS) = Real: This function is the same as to_float(NS).
-----
Lists
List1 ++ List2 = List: This function returns the concatenated list of List1 and List2.
 append(X,Y ,Z) (nondet): This predicate is true if appending Y to X can create Z. This predicate may backtrack if X is not a complete list.1
 append(W,X,Y ,Z) (nondet): This predicate is defined as:
    append(W,X,Y,Z) => append(W,X,WX), append(WX,Y,Z).
avg(List) = V al: This function returns the average of all the elements in List. This function throws an exception if List is not a list or any of the elements is not a number.
delete(List,X) = ResList: This function deletes the first occurrence of X from List, returning the result in ResList. The built-in !=/2 is used to test if two terms are different. No variables in List or X will be bound after this function call.
delete_all(List,X) = ResList: This function deletes all occurrences of X from List, returning the result in ResList. The built-in !=/2 is used to test if two terms are different.
first(List) = Term: This function returns the first element of List.
flatten(List) = ResList: This function flattens a list of nested lists into a list. For example, flatten([[1],[2,[3]]]) returns [1,2,3].
head(List) = Term: This function returns the head of the list List. For example, head([1,2,3]) returns 1.
insert(List,Index,Elm) = ResList: This function inserts Elm into List at the index Index, returning the result in ResList. After insertion, the original List is not changed, and ResList is the same as
List.slice(1,Index-1)++[Elm|List.slice(Index,List.length)].
insert_all(List,Index,AList) = ResList: This function inserts all of the elements in AList into List at the index Index, returning the result in ResList. After insertion, the original List is not changed, and ResList is the same as
List.slice(1,Index-1)++AList++List.slice(Index,List.length).
insert_ordered(List,Term): This function inserts Term into the ordered list List, such that the resulting list remains sorted.
insert_ordered_down(List,Term): This function inserts Term into the descendantly ordered list List, such that the resulting list remains sorted down.
last(List) = Term: This function returns the last element of List.
len(List) = Len: This function returns the number of elements in List. Note that this function is overloaded in such a way that the argument can also be an atom, an array, or a structure.
length(List) = Len: This function is the same as len(List).
list(Term): This predicate is true if Term is a list.
max(List) = V al: This function returns the maximum value that is in List, where List is a list of terms.
membchk(Term,List): This predicate is true if Term is an element of List.
member(Term,List) (nondet): This predicate is true if Term is an element of List. When Term is a variable, this predicate may backtrack, instantiating Term to different elements of List.
min(List) = V al: This function returns the minimum value that is in List, where List is a list or an array of terms.
new_list(N) = List: This function creates a new list that has N free variable arguments.
new_list(N,InitV al) = List: This function creates a new list that has N arguments all initialized to InitV al.
nth(Index,List,Elem) (nondet): This predicate is true when Elem is the Index’th element of List. Counting starts at 1. When Index is a variable, this predicate may backtrack, instantiating Index to a different integer between 1 and len(List).
prod(List) = V al: This function returns the product of all of the values in List.
remove_dups(List) = ResList: This function removes all duplicate values from List, retaining only the first occurrence of each value. The result is returned in ResList. Note that an O(n2) algorithm is used in the implementation. If List is large, then sort_remove_dups(List) may be faster than this function.
reverse(List) = ResList: This function reverses the order of the elements in List, returning the result in ResList.
select(X,List,ResList) (nondet): This predicate nondeterministically selects an element X from List, and binds ResList to the list after X is removed. On backtracking, it selects the next element.
sort(List) = SList: This function sorts the elements of List in ascending order, returning the result in SList.
sort(List,KeyIndex) = SList: This function sorts the elements of List by the key index KeyIndex in ascending order, returning the result in SList. The elements of List must be compound values and KeyIndex must be a positive integer that does not exceed the length of any of the elements of List. This function is defined as follows:
    sort(List,KeyIndex) = SList =>  
        List1 = [(E[KeyIndex],E) : E in List],  
        List2 = sort(List1),  
        SList = [E : (_,E) in List2].
sort_remove_dups(List) = SList: This function is the same as the following, but is faster.
sort(List).remove_dups()
sort_remove_dups(List,KeyIndex) = SList: This function is the same as the following, but is faster.
sort(List,KeyIndex).remove_dups()
sort_down(List) = SList: This function sorts the elements of List in descending order, returning the result in SList. sort_down(List,KeyIndex) = SList: This function sorts the elements of List by the key index KeyIndex in descending order, returning the result in SList. sort_down_remove_dups(List) = SList: This function is the same as the following, but is faster.
sort_down(List).remove_dups()
sort_down_remove_dups(List,KeyIndex) = SList: This function is the same as the following, but is faster.
sort_down(List,KeyIndex).remove_dups()
slice(List,From,To) = SList: This function returns the sliced list of List from index From through index To. From must not be less than 1. It is the same as the index notation List[From..To]. slice(List,From) = SList: This function is the same as the following.
slice(List,From,List.length)
sum(List) = V al: This function returns the sum of all of the values in List. tail(List) = Term: This function returns the tail of the list List. For example, the call tail([1,2,3]) returns [2,3]. to_array(List) = Array: This function converts the list List to an array. The elements of the array are in the same order as the elements of the list. zip(List1 ,List2,…,Listn) = List: This function makes a list of array tuples. The jth tuple in the list takes the form {E1j,…,Enj}, where Eij is the jth element in Listi. In the current implementation, n can be 2, 3, or 4.
-----
Strings
string(Term): This predicate is true if Term is a string.
to_lowercase(String) = LString: This function converts all uppercase alphabetic characters into lowercase characters, returning the result in LString.
to_uppercase(String) = UString: This function converts all lowercase alphabetic characters into uppercase characters, returning the result in UString.
-----
Structures
T =.. L: The name and the arguments of T comprise the list L. This predicate extracts the name and arguments of T when T is instantiated, and constructs T from the list L when L is instantiated.
arg(I,T,A): The Ith argument of the term T is A. This predicate is the equivalent to: X = T, A = X[I], except when I is 0 or T is a list. When I is 0, the call fails. When T is a list, only two indices, namely 1 and 2, are acceptable. For I = 1, A is unified with the car of the list, and for I = 2, A is unified with the cdr of the list.
arity(Struct) = Arity: This function returns the arity of Struct, which must be a structure.
functor(T,F,N): The principal functor of the term T has the name F and the arity N. This predicate extracts the functor F∕N of T when T is instantiated, and constructs a term T of the given functor F∕N when T is a variable.
len(Struct) = Arity: This function is the same as arity(Struct).
name(Struct) = Name: This function returns the name of Struct.
new_struct(Name,IntOrList) = Struct: This function creates a structure that has the name Name. If IntOrList is an integer, N, then the structure has N free variable arguments. Otherwise, if IntOrList is a list, then the structure contains the elements in the list.
struct(Term): This predicate is true if Term is a structure.
to_list(Struct) = List: This function returns a list of the components of the structure Struct.
-----
Arrays
array(Term): This predicate is true if Term is an array.
new_array(D1,…,Dn) = Arr: This function creates an n-dimensional array, where each Di is an integer expression that specifies the size of a dimension. In the current implementation, n cannot exceed 10.
Array1 ++ Array2 = Array
avg(Array) = V al
first(Array) = Term
last(Array) = Term
len(Array) = Len
length(Array) = Len
max(Array) = V al
min(Array) = V al
nth(Index,List,Elem) (nondet)
reverse(Array) = ResArray
slice(Array,From,To) = SArray
slice(Array,From) = SArray
sum(Array) = V al
sort(Array) = SArray
sort(Array,KeyIndex) = SArray
sort_remove_dups(Array) = SArray
sort_remove_dups(Array,KeyIndex) = SArray
sort_down(Array) = SArray
sort_down(Array,KeyIndex) = SArray
sort_down_remove_dups(Array) = SArray
sort_down_remove_dups(Array,KeyIndex) = SArray
-----
Maps
clear(Map): This predicate clears the map Map. It throws an error if Map is not a map.
get(Map,Key) = V al: This function returns V al of the key-value pair Key=V al in Map. It throws an error if Map does not contain the key Key.
get(Map,Key,DefaultV al) = V al: This function returns V al of the key-value pair Key=V al in Map. It returns DefaultV al if Map does not contain Key.
has_key(Map,Key): This predicate is true if Map contains a pair with Key.
keys(X) = List: This function returns the list of keys of the pairs in Map.
map(Term): This predicate is true if Term is a map.
map_to_list(Map) = PairsList: This function returns a list of Key=V al pairs that constitute Map.
new_map(IntOrPairsList) = Map: This function creates a map with an initial capacity or an initial list of pairs.
new_map(N,PairsList) = Map: This function creates a map with the initial capacity N, the initial list of pairs PairsList, where each pair has the form Key=V al.
put(Map,Key,V al): This predicate attaches the key-value pair Key=V al to Map, where Key is a non-variable term, and V al is any term.
put(Map,Key): This predicate is the same as put(Map,Key, not_a_value).
values(Map) = List: This function returns the list of values of the pairs in Map.
size(Map) = Size: This function returns the number of pairs in Map.
-----
Sets
new_set(IntOrKeysList) = Set: This function creates a set with an initial capacity or an initial list of keys.
new_set(N,KeysList) = Set: This function creates a set with the initial capacity N and the initial list of keys KeysList.
-----
Heaps
heap_is_empty(Heap): This predicate is true if Heap is empty.
heap_pop(Heap) = Elm: This function removes the root element from the heap, and returns the element. As the function updates the heap, it is not pure. The update will be undone when execution backtracks over the call.
heap_push(Heap,Elm): This predicate pushes Elm into Heap in a way that maintains the heap property. The update to Heap will be undone when execution backtracks over the call.
heap_size(Heap) = Size: This function returns the size of Heap.
heap_to_list(Heap) = List: This function returns a list of the elements in Heap.
heap_top(Heap) = Elm: This function returns the element at the root of the heap. If Heap is a min-heap, then the element is guaranteed to be the minimum, and if Heap is a max-heap, then the element is guaranteed to be the maximum.
new_max_heap(IntOrList) = Heap: This function creates a max-heap. If IntOrList is an integer, then it indicates the capacity. Otherwise, if IntOrList is a list, then the max-heap contains the elements in the list in an order that maintains the heap property.
new_min_heap(IntOrList) = Heap: This function creates a min-heap. If IntOrList is an integer, then it indicates the capacity. Otherwise, if IntOrList is a list, then the min-heap contains the elements in the list in an order that maintains the heap property.
-----
Higher-order
apply(S,Arg1,…,Argn) = V al: S is an atom or a structure. This function calls the function that is named by S with the arguments that are specified in S, together with extra arguments Arg1, …, Argn. This function returns the value that S returns.
call(S,Arg1,…,Argn): S is an atom or a structure. This predicate calls the predicate that is named by S with the arguments that are specified in S, together with extra arguments Arg1 , …, Argn.
call_cleanup(Call,Cleanup): This predicate is the same as call(Call), except that Cleanup is called when Call succeeds determinately (i.e., with no remaining choice point), when Call fails, or when Call raises an exception.
catch(Call,Exception,Handler): This predicate is the same as Call, except when an exception that matches Exception is raised during the execution of Call. When such an exception is raised, all of the bindings that have been performed on variables in Call will be undone, and Handler will be executed to handle the exception.
count_all(Call) = Count: This function returns the number of all possible instances of call(Call) that are true. For example, count_all(member(X,[1,2,3])) returns 3.
findall(Template,Call) = Answers: This function returns a list of all possible instances of call(Call) that are true in the form of Template. Note that Template is assumed to be a term without function calls, and that Call is assumed to be a predicate call whose arguments can contain function calls. Also note that, like a loop, findall forms a name scope. For example, in findall(f(X),p(X,g(Y))), f(X) is a term even though it is not preceded with $; g(Y) is a function call; the variables X and Y are assumed to be local to findall if they do not occur before in the outer scope.
find_all(Template,Call) = Answers: This function is the same as the above function.
freeze(X,Call): This predicate delays the evaluation of Call until X becomes a non-variable term.
map(FuncOrList,ListOrFunc) = ResList: This function applies a given function to every element of a given list and returns a list of the results. One of the arguments is a function, and the other is a list. The order of the arguments is not important.
map(Func,List1,List2) = ResList: Let List1 be [A1,…,An] and List2 be [B1 ,… ,Bn]. This function applies the function Func to every pair of elements (Ai,Bi) by calling apply(Func,Ai,Bi), and returns a list of the results.
maxof(Call,Objective): This predicate finds a satisfiable instance of Call, such that Objective has the maximum value. Here, Call is used as a generator, and Objective is an expression to be maximized. For every satisfiable instance of Call, Objective must be a ground expression. For maxof, search is restarted with a new bound each time that a better answer is found.
maxof(Call,Objective,ReportCall): This is the same as maxof(Call,Objective), except that call(ReportCall) is executed each time that an answer is found.
maxof_inc(Call,Objective): This is the same as maxof(Call,Objective), except that search continues rather than being restarted each time that a better solution is found.
maxof_inc(Call,Objective,ReportCall): This is the same as the previous predicate, except that call(ReportCall) is executed each time that an answer is found.
minof(Call,Objective): This predicate finds a satisfiable instance of Call, such that Objective has the minimum value.
minof(Call,Objective,ReportCall): This is the same as minof(Call,Objective), except that call(ReportCall) is executed each time that an answer is found.
minof_inc(Call,Objective): This predicate is the same as minof(Call,Objective), except that search continues rather than being restarted each time that a better solution is found.
minof_inc(Call,Objective,ReportCall): This predicate is the same as the previous one, except that call(ReportCall) is executed each time that an answer is found.
reduce(Func,List) = Res: If List is a list that contains only one element, this function returns the element. If List contains at least two elements, then the first two elements A1 and A2 are replaced with apply(Func,A1,A2). This step is repeatedly applied to the list until the list contains a single element, which is the final value to be returned. The order of the arguments is not important, meaning that the first argument can be a list and the second one can be a function.
reduce(Func,List,InitV al) = Res: This function is the same as
reduce(Func,[InitV al|List]).
-----
Math
abs(X) = V al
acos(X) = V al
acosh(X) = V al
acot(X) = V al
acoth(X) = V al
acsc(X) = V al
acsch(X) = V al
asec(X) = V al
asech(X) = V al
asin(X) = V al
asinh(X) = V al
atan(X) = V al
atan2(X,Y ) = V al
atanh(X) = V al
ceiling(X) = V al
cos(X) = V al
cosh(X) = V al
cot(X) = V al
coth(X) = V al
csc(X) = V al
csch(X) = V al
e() = 2.71828182845904523536
even(Int)
exp(X) = V al
floor(X) = V al
frand() = V al
frand(Low,High) = V al
gcd(A,B) = V al
log(X) = V al
log(B,X) = V al
log10(X) = V al
log2(X) = V al
modf(X) = (IntV al,FractV al)
odd(Int)
pi() = 3.14159265358979323846
pow(X,Y ) = V al
pow_mod(X,Y ,Z) = V al
prime(Int)
primes(Int) = List
rand_max() = V al
random = V al
random(Low,High) = V al
random(Seed) = V al
random2() = Int
round(X) = V al
sec(X) = V al
sech(X) = V al
sign(X) = V al
sin(X) = V al
sinh(X) = V al
sqrt(X) = V al
tan(X) = V al
tanh(X) = V al
to_degrees(Radian) = Degree
to_radians(Degree) = Radian
truncate(X) = V al
-----
Exceptions
throw(Exception): throws Exception
catch(Goal,Exception,RecoverGoal)
zero_divisor(Source): Source divides a number by zero.
domain_error(V al,Source): Source receives a value V al that is unexpected in the domain.
existence_error(Entity,Source): Source tries to use Entity, such as a file, a function, or a solver, that does not exist.
interrupt(Source): The execution is interrupted by a signal. For an interrupt caused by ctrl-c, Source is keyboard.
io_error(ENo,EMsg,Source): An I/O error with the number ENo and message EMsg occurs in Source.
load_error(FName,Source): An error occurs while loading the byte-code file named FName. This error is caused by the malformatted byte-code file.
out_of_memory(Area): The system runs out of memory while expanding Area, which can be: stack_heap, trail, program, table, or findall.
out_of_bound(EIndex,Source): Source tries to access an element of a compound value using the index EIndex, which is out of bound. An index is out of bound if it is less than or equal to zero, or if it is greater than the length of the compound value.
syntax_error(String,Source): String cannot be parsed into a value that is expected by Source. For example, read_int() throws this exception if it reads in a string "a" rather than an integer.
unresolved_function_call(FCall): No rule is applicable to the function call FCall.
Type_expected(EArg,Source): The argument EArg in Source is not an expected type or value, where Type can be var, nonvar, dvar, atom, integer, real, number, list, map, etc.
-----
IO
read_int(FD) = Int: This function reads a single integer from the file that is represented by FD. It throws an input_mismatch exception if FD is at the end of the file or the next token at FD is not an integer.
read_int() = Int: This function is the same as read_int(stdin).
read_real(FD) = Real: This function reads a single real number from the file that is represented by FD. It throws an input_mismatch exception if FD is at the end of the file or the next token at FD is not a number.
read_real() = Real: This function is the same as read_real(stdin).
read_char(FD) = V al: This function reads a single UTF-8 character from the file that is represented by FD. It returns end_of_file if FD is at the end of the file.
read_char() = V al: This function is the same as read_char(stdin).
read_char(FD,N) = String: This function reads up to N UTF-8 characters from the file that is represented by FD. It returns a string that contains the characters that were read.
read_char_code(FD) = V al: This function reads a single UTF-8 character from the file that is represented by FD and returns its code point. It returns -1 if FD is at the end of the file.
read_char_code() = V al: This function is the same as read_char_code(stdin).
read_char_code(FD,N) = List: This function reads up to N UTF-8 characters from the file that is represented by FD. It returns a list of code points of the characters that were read.
read_picat_token(FD,TokenType,TokenV alue): This predicate reads a single Picat token from the file that is represented by FD. TokenType is the type and TokenV alue is the value of the token. TokenType is one of the following: atom, end_of_file, end_of_rule, integer, punctuation, real, string, underscore, and var.
read_picat_token(TokenType,TokenV alue): This predicate reads a token from stdin.
read_picat_token(FD) = TokenV alue: This function reads a single Picat token from the file that is represented by FD and returns the token value.
read_picat_token() = TokenV alue: This function is the same as the above, except that it reads from stdin.
read_term(FD) = Term: This function reads a single Picat term from the file that is represented by FD. The term must be followed by a dot ‘.’ and at least one whitespace character. This function consumes the dot symbol. The whitespace character is not stored in the returned string.
read_term() = Term: This function is the same as read_term(stdin).
read_line(FD) = String: This function reads a string from the file that is represented by FD, stopping when either a newline (‘\r\n’ on Windows, and ‘\n’ on Unix) is read, or the end_of_file atom is returned. The newline is not stored in the returned string.
read_line() = String: This function is the same as read_line(stdin).
readln(FD) = String: This function does the same thing as read_line.
readln() = String: This function is the same as readln(stdin).
read_byte(FD) = V al: This function reads a single byte from the file that is represented by FD.
read_byte() = V al: This function is the same as read_byte(stdin).
read_byte(FD,N) = List: This function reads up to N bytes from the file that is represented by FD. It returns the list of bytes that were read.
read_file_bytes(File) = List: This function reads an entire byte file into a list.
read_file_bytes() = List: This function reads an entire byte file from the console into a list.
read_file_chars(File) = String: This function reads an entire character file into a string.
read_file_chars() = String: This function reads an entire character file from the console into a string.
read_file_codes(File) = List: This function reads UTF-8 codes of an entire character file into a list.
read_file_codes() = List: This function reads UTF-8 codes of an entire character file from the console into a list.
read_file_lines(File) = Lines: This function reads an entire character file into a list of line strings.
read_file_lines() = Lines: This function reads an entire character file from the console into a list of line strings.
read_file_terms(File) = Lines: This function reads an entire text file into a list of terms. In the file, each term must be terminated by ‘.’ followed by at least one white space.
read_file_terms() = Lines: This function reads an entire text file from the console into a list of terms.
peek_char(FD) = Val
peek_byte(FD) = Val
at_end_of_stream(FD): The at_end_of_stream predicate is demonstrated in the following example.
write(FD,Term): This predicate writes Term to a file. Single-character lists are treated as strings. Strings are double-quoted, and atoms are single-quoted when necessary. This predicate does not print a newline, meaning that the next write will begin on the same line.
write(Term): This predicate is the same as write(stdout,Term).
write_byte(FD,Bytes): This predicate writes a single byte or a list of bytes to a file.
write_byte(Bytes): This predicate is the same as write_byte(stdout,Bytes).
write_char(FD,Chars): This predicate writes a single character or a list of characters to a file. The characters are not quoted. When writing a single-character atom Char, write_char(FD,Char) is the same as print(FD,Char), but write_char is faster than print.
write_char(Chars): This predicate is the same as write_char(stdout,Chars).
write_char_code(FD,Codes): This predicate writes a single character or a list of characters of the given code or list of codes to a file.
write_char_code(Codes): This predicate is the same as the above, except that it writes to stdout.
writeln(FD,Term): This predicate writes Term and a newline, meaning that the next write will begin on the next line.
writeln(Term): This predicate is the same as writeln(stdout,Term).
writef(FD,Format,Args…): This predicate is used for formatted writing, where the Format parameter contains format characters that indicate how to print each of the arguments in the Args parameter. The number of arguments in Args… cannot exceed 16.
print(FD,Term): This predicate prints Term to a file. Unlike the write predicates, the print predicates do not place quotes around strings and atoms.
print(Term): This predicate is the same as print(stdout,Term).
println(FD,Term) This predicate prints Term and a newline.
println(Term) This predicate is the same as println(stdout,Term).
printf(FD,Format,Args…): This predicate is the same as writef, except that printf uses print to display the arguments in the Args parameter, while writef uses write to display the arguments in the Args parameter. The number of arguments in Args… cannot exceed 16.
flush(FD): This predicate causes all buffered data to be written without delay.
close(FD): This predicate causes the file to be closed, releasing the file’s resources, and removing the file from the file descriptor table. Any further attempts to write to the file descriptor without calling open will cause an error to be thrown.
-----
Events
post_event_ins(X): posts an event to the ins-port of the channel X.
post_event_bound(X): posts an event to the bound-port of the channel X.
post_event_dom(X,T): posts the term T to the dom-port of the channel X.
post_event_any(X,T): posts the event T to the any-port of the channel of X.
event(X,T): This is the general event pattern. The actor is attached to the dom-ports of the variables in X. The actor will be activated by events posted to the dom-ports. T must be a variable that does not occur before event(X,T) in the rule.
ins(X): The actor is attached to the ins-ports of the variables in X. The actor will be activated when a variable in X is instantiated.
bound(X): The actor is attached to the bound-ports of the variables in X. The actor will be activated when the lower bound or upper bound of the domain of a variable in X changes.
dom(X): The actor is attached to the dom-ports of the variables in X. The actor will be activated when an inner value is excluded from the domain of a variable in X. The actor is not interested in what value is actually excluded.
dom(X,E): This is the same as dom(X), except the actor is interested in the value E that is excluded. E must be a variable that does not occur before dom(X,E) in the rule.
dom_any(X): The actor is attached to the any-ports of the variables in X. The actor will be activated when an arbitrary value, including the lower bound value and the upper bound value, is excluded from the domain of a variable in X. The actor is not interested in what value is actually excluded.
dom_any(X,E): This is the same as dom_any(X), except the actor is interested in the value E that is actually excluded. E must be a variable that does not occur before dom_any(X,E) in the rule.
-----
Lazy
freeze(X,Goal) is equivalent to ‘once Goal’, but its evaluation is delayed until X is bound to a non-variable term.
     freeze(X,Goal), var(X), {ins(X)} => true.  
     freeze(X,Goal) => call(Goal).
 For the call freeze(X,Goal), if X is a variable, then X is registered as an actor on the ins-port of X, and X is then suspended. Whenever X is bound, the event ins is posted to the ins-port of X, which activates the actor freeze(X,Goal). The condition var(X) is checked. If true, the actor is suspended again; otherwise, the second rule is executed, causing the actor to vanish after it is rewritten into once Goal.
-----
OS
separator() = Val
listdir(Path) = List: This function returns a list of all of the files and directories that are contained inside the directory specified by Path. If Path is not a directory, then an error is thrown. The returned list contains strings, each of which is the name of a file or directory.
cwd() = Path
pwd() = Path
cd(Path)
chdir(Path)
mkdir(Path): This predicate creates a new directory at location Path. The directory will be created with a default permission list of [rwu, rwg, ro]. If the program does not have permission to write to the parent directory of Path, this predicate will throw an error. An error will also occur if the parent directory does not exist.
rename(Old,New): This renames a file or a directory from Old to New. This predicate will throw an error if Old does not exist. An error will also occur if the program does not have permission to write to Old or New.
cp(FromPath,ToPath): This copies a file from FromPath to ToPath. This predicate will throw an error if FromPath does not exist or FromPath is a directory. An error will also occur if the program does not have permission to read from FromPath, or if it does not have permission to write to ToPath.
rm(Path): This deletes a file. An error will be thrown if the file does not exist, if the program does not have permission to delete the file, or if Path refers to a directory, a hard link, a symbolic link, or a special file type.
rmdir(Path): This deletes a directory. An error will be thrown if the directory does not exist, the program does not have permission to delete the directory, the directory is not empty, or if Path does not refer to a directory.
readable(Path): Is the program allowed to read from the file?
writable(Path): Is the program allowed to write to the file?
executable(Path): Is the program allowed to execute the file?
size(Path) = Int: If Path is not a symbolic link, then this function returns the number of bytes contained in the file to which Path refers. If Path is a symbolic link, then this function returns the path size of the symbolic link. Because the function size/1 is defined in the basic module for returning the size of a map, this function requires an explicit module qualifier os.size(Path).
file_base_name(Path) = List: This function returns a string containing the base name of Path. For example, the base name of “a/b/c.txt” is “c.txt”.
file_directory_name(Path) = List: This function returns a string containing the path of the directory that contains Path. For example, the directory name of “a/b/c.txt” is “a/b/”.
exists(Path): Is Path an existing file or directory?
file(Path): Does Path refer to a regular file? This predicate is true if Path is neither a directory nor a special file, such as a socket or a pipe.
file_exists(Path): This tests whether Path exists, and, if it exists, whether Path refers to a regular file.
directory(Path): Does Path refer to a directory?
env_exists(Name): This predicate succeeds if Name is an environment variable in the system.
getenv(Name) = String: This function returns the value of the environment variable Name as a string. This function will throw an error if the environment variable Name does not exist.
